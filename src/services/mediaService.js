const { Media, Message, User } = require('../models');
const redisClient = require('../utils/redisClient');
const logger = require('../utils/logger');
const { uploadFile, deleteFile, generateThumbnail, compressImage } = require('../utils/fileUpload');

class MediaService {
  async uploadMedia(userId, file, options = {}) {
    try {
      // Validate file
      this.validateFile(file, options);

      // Prepare upload options
      const uploadOptions = {
        folder: options.folder || 'media',
        transformation: options.transformation,
        generateThumbnail: options.generateThumbnail,
        compress: options.compress,
        maxSize: options.maxSize,
      };

      // Upload file
      const uploadResult = await uploadFile(file, uploadOptions);

      // Create media record
      const media = await Media.create({
        userId,
        filename: uploadResult.filename,
        originalName: file.originalname,
        url: uploadResult.url,
        thumbnailUrl: uploadResult.thumbnailUrl,
        type: this.getMediaType(file.mimetype),
        mimeType: file.mimetype,
        size: file.size,
        dimensions: uploadResult.dimensions,
        duration: uploadResult.duration,
        caption: options.caption,
        altText: options.altText,
        isCompressed: uploadResult.isCompressed || false,
        compressionQuality: uploadResult.compressionQuality,
        storageProvider: uploadResult.storageProvider || 'local',
        storagePath: uploadResult.storagePath,
        isPublic: options.isPublic || false,
        metadata: options.metadata || {},
      });

      // Generate access token if public
      if (media.isPublic) {
        await media.reload(); // To get access token generated by hook
      }

      return media;
    } catch (error) {
      logger.error('Upload media error:', error);
      throw error;
    }
  }

  async getMedia(mediaId, userId) {
    try {
      const media = await Media.findByPk(mediaId);
      if (!media) {
        throw new Error('Media not found');
      }

      // Check authorization
      if (media.userId !== userId && !media.isPublic) {
        throw new Error('Not authorized to access this media');
      }

      return media;
    } catch (error) {
      logger.error('Get media error:', error);
      throw error;
    }
  }

  async getMediaByAccessToken(accessToken) {
    try {
      const media = await Media.findByAccessToken(accessToken);
      if (!media) {
        throw new Error('Media not found or access denied');
      }

      return media;
    } catch (error) {
      logger.error('Get media by access token error:', error);
      throw error;
    }
  }

  async getUserMedia(userId, options = {}) {
    try {
      const cacheKey = `user:${userId}:media:${JSON.stringify(options)}`;
      const cached = await redisClient.get(cacheKey);

      if (cached) {
        return JSON.parse(cached);
      }

      const media = await Media.getUserMedia(userId, options);

      // Cache for 5 minutes
      await redisClient.setex(cacheKey, 300, JSON.stringify(media));

      return media;
    } catch (error) {
      logger.error('Get user media error:', error);
      throw error;
    }
  }

  async getChatMedia(chatId, userId, options = {}) {
    try {
      // Check if user is participant in chat
      const Chat = require('../models').Chat;
      const chat = await Chat.findByPk(chatId);
      if (!chat) {
        throw new Error('Chat not found');
      }

      const isParticipant = await chat.isParticipant(userId);
      if (!isParticipant) {
        throw new Error('Not authorized to view chat media');
      }

      const cacheKey = `chat:${chatId}:media:${JSON.stringify(options)}`;
      const cached = await redisClient.get(cacheKey);

      if (cached) {
        return JSON.parse(cached);
      }

      const media = await Media.getChatMedia(chatId, options);

      // Cache for 5 minutes
      await redisClient.setex(cacheKey, 300, JSON.stringify(media));

      return media;
    } catch (error) {
      logger.error('Get chat media error:', error);
      throw error;
    }
  }

  async updateMedia(mediaId, userId, updateData) {
    try {
      const media = await Media.findByPk(mediaId);
      if (!media) {
        throw new Error('Media not found');
      }

      // Check authorization
      if (media.userId !== userId) {
        throw new Error('Not authorized to update this media');
      }

      // Update media
      const allowedFields = ['caption', 'altText', 'isPublic', 'metadata'];
      const updates = {};

      allowedFields.forEach(field => {
        if (updateData[field] !== undefined) {
          updates[field] = updateData[field];
        }
      });

      // Generate new access token if making public
      if (updateData.isPublic === true && !media.isPublic) {
        updates.accessToken = require('crypto').randomBytes(16).toString('hex');
      }

      // Clear access token if making private
      if (updateData.isPublic === false && media.isPublic) {
        updates.accessToken = null;
      }

      await media.update(updates);

      // Clear cache
      await this.clearMediaCache(mediaId, userId);

      return media;
    } catch (error) {
      logger.error('Update media error:', error);
      throw error;
    }
  }

  async deleteMedia(mediaId, userId) {
    try {
      const media = await Media.findByPk(mediaId);
      if (!media) {
        throw new Error('Media not found');
      }

      // Check authorization
      if (media.userId !== userId) {
        throw new Error('Not authorized to delete this media');
      }

      // Delete file from storage
      await deleteFile(media.url);

      if (media.thumbnailUrl) {
        await deleteFile(media.thumbnailUrl);
      }

      // Delete media record
      await media.destroy();

      // Clear cache
      await this.clearMediaCache(mediaId, userId);

      return true;
    } catch (error) {
      logger.error('Delete media error:', error);
      throw error;
    }
  }

  async compressMedia(mediaId, userId, quality = 80) {
    try {
      const media = await Media.findByPk(mediaId);
      if (!media) {
        throw new Error('Media not found');
      }

      // Check authorization
      if (media.userId !== userId) {
        throw new Error('Not authorized to compress this media');
      }

      // Check if media is compressible
      if (!['image', 'video'].includes(media.type)) {
        throw new Error('Only images and videos can be compressed');
      }

      if (media.isCompressed) {
        return media;
      }

      // Compress media
      let compressedResult;
      if (media.type === 'image') {
        compressedResult = await compressImage(media.url, quality);
      } else {
        // Video compression would require a video processing library
        // For now, just mark as compressed
        compressedResult = { url: media.url, isCompressed: true };
      }

      // Update media record
      media.url = compressedResult.url;
      media.isCompressed = true;
      media.compressionQuality = quality;
      await media.save();

      // Clear cache
      await this.clearMediaCache(mediaId, userId);

      return media;
    } catch (error) {
      logger.error('Compress media error:', error);
      throw error;
    }
  }

  async generateThumbnailForMedia(mediaId, userId) {
    try {
      const media = await Media.findByPk(mediaId);
      if (!media) {
        throw new Error('Media not found');
      }

      // Check authorization
      if (media.userId !== userId) {
        throw new Error('Not authorized to generate thumbnail for this media');
      }

      // Check if thumbnail already exists
      if (media.thumbnailUrl) {
        return media;
      }

      // Check if media type supports thumbnails
      if (!['image', 'video'].includes(media.type)) {
        throw new Error('Thumbnails only supported for images and videos');
      }

      // Generate thumbnail
      const thumbnailResult = await generateThumbnail(media.url);

      // Update media record
      media.thumbnailUrl = thumbnailResult.url;
      await media.save();

      // Clear cache
      await this.clearMediaCache(mediaId, userId);

      return media;
    } catch (error) {
      logger.error('Generate thumbnail error:', error);
      throw error;
    }
  }

  async getMediaStats(userId) {
    try {
      const cacheKey = `user:${userId}:media:stats`;
      const cached = await redisClient.get(cacheKey);

      if (cached) {
        return JSON.parse(cached);
      }

      const stats = await Media.findAll({
        where: { userId },
        attributes: [
          'type',
          [require('../models').sequelize.fn('COUNT', '*'), 'count'],
          [require('../models').sequelize.fn('SUM', 'size'), 'totalSize'],
        ],
        group: ['type'],
      });

      const totalStats = await Media.findAll({
        where: { userId },
        attributes: [
          [require('../models').sequelize.fn('COUNT', '*'), 'totalCount'],
          [require('../models').sequelize.fn('SUM', 'size'), 'overallSize'],
        ],
      });

      const result = {
        byType: stats.map(stat => ({
          type: stat.type,
          count: parseInt(stat.dataValues.count),
          totalSize: parseInt(stat.dataValues.totalSize) || 0,
        })),
        total: {
          count: parseInt(totalStats[0]?.dataValues.totalCount) || 0,
          size: parseInt(totalStats[0]?.dataValues.overallSize) || 0,
        },
      };

      // Cache for 1 hour
      await redisClient.setex(cacheKey, 3600, JSON.stringify(result));

      return result;
    } catch (error) {
      logger.error('Get media stats error:', error);
      throw error;
    }
  }

  async cleanupOrphanedMedia(days = 30) {
    try {
      const count = await Media.cleanupOrphaned(days);
      logger.info(`Cleaned up ${count} orphaned media files`);
      return count;
    } catch (error) {
      logger.error('Cleanup orphaned media error:', error);
      throw error;
    }
  }

  validateFile(file, options) {
    const config = require('../config').upload;
    const maxFileSize = options.maxSize || config.maxFileSize;

    // Check file size
    if (file.size > maxFileSize) {
      throw new Error(`File too large. Maximum size is ${maxFileSize / 1024 / 1024}MB`);
    }

    // Check file type
    const allowedTypes = [
      ...config.allowedImageTypes,
      ...config.allowedVideoTypes,
      ...config.allowedAudioTypes,
    ];

    if (!allowedTypes.includes(file.mimetype)) {
      throw new Error('Invalid file type');
    }
  }

  getMediaType(mimeType) {
    if (mimeType.startsWith('image/')) return 'image';
    if (mimeType.startsWith('video/')) return 'video';
    if (mimeType.startsWith('audio/')) return 'audio';
    return 'file';
  }

  async clearMediaCache(mediaId, userId) {
    const patterns = [`user:${userId}:media:*`, `chat:*:media:*`, `user:${userId}:media:stats`];

    for (const pattern of patterns) {
      const keys = await redisClient.keys(pattern);
      if (keys.length > 0) {
        await redisClient.del(keys);
      }
    }
  }
}

module.exports = new MediaService();
